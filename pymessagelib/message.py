"""
This module contains the Message class, which is an abstract base class for all user-defined 
messages.

Created on Jan 9, 2021

:author: smalbadger
"""

from abc import ABC
import inspect
from typing import Dict
from copy import deepcopy

from field import Field
from _exceptions import (
    InvalidDataFormatException,
    MissingFieldDataException,
    InvalidFieldDataException,
    CircularDependencyException,
)


class Message(ABC):
    """
    Subclasses of the Message class are dynamically generated by a MessageBuilder object. To
    generate subclasses, user-defined message definitions must be loaded into the MessageBuilder.
    Message definitions map field names to Field objects. The Field objects instantiated in the message
    definitions are not to be used for any other purpose than to define field attributes. Below is an
    example of a message definition:

    msg_defs = {
        "INPUTS" : {
            "service_req": Bit(1),
            "voltage_ready": Bit(1),
            "exit_code": Bytes(2),
            "last_command_id": Bits(2),
            "unused": Byte(1, value="x0"),
        }
    }

    In the example above, Bit, Bytes, Bits, and Byte are all derived from the Field class

    .. seealso:
        The Field class documentation describes valid Field subclasses and parameters in more detail.

    When a class for the above message definition is generated, a Message object can be instantiated
    using the name of the message as the constructor. Only values for writable fields can be specified.
    Writable fields with a default value can be specified if desired, but values for writable fields without a
    default value *MUST* be specified. For example:

    #TODO: Implement default values for writable fields

    INPUTS(service_req='b1', voltage_ready='b0', exit_code='x0001', last_command_id='b11').

    All values will be checked for validity based on criteria of the Field object in the message definition.

    .. seealso:
        The MessageBuilder class describes how to generate subclasses from message definitions

    Message objects can represent either an entire message or they can represent a portion of a message
    by being nested inside a field. Nesting fields allows for:

        - Less repeated code when there are multiple messages with similar components.
        - Assigning additional meaning to fields dynamically.
        - Establishing a hierarchy of information within messages.

    Individual fields can be compared, but comparison at the message level means comparing
    each field of 2 messages.
    """

    def __init__(self, fields: Dict):

        # Fields need to be deep copied so the same field objects aren't shared
        # across all message instances of the same type.
        self._fields = deepcopy(fields)  # maps field names to field objects
        self._parent_field = None

    @staticmethod
    def _create_setter(name, field):
        """Used for dynamically creating setters for fields of subclasses."""

        def set_field(self, value):
            """
            Used as the setter function for all writable fields in a message. fields of all other
            types will *not* have an associated setter.

            When this function is called, all auto-update fields of the field's parent message
            will be updated since they might rely on this field.

            :raises: InvalidFieldDataException if the data being set is not valid for this field.
            """
            if not field.value_is_valid(value):
                raise InvalidFieldDataException(f"{value} is not a valid value for {field}")
            self._fields[name].value = value
            self.update_fields()

        return set_field

    @staticmethod
    def _create_getter(name):
        """Used for dynamically creating getters for field properties of subclasses."""

        def get_field(self):
            """
            Used as the getter function for all fields in a message regardless of the field type.

            If this is for a nested-field, a new object of the field context type will be
            instantiated and returned. Else, the Field object belonging to this instance will be
            returned.
            """
            field = self._fields[name]
            if field.context is not None:
                msg = field.value
                msg._parent_field = field
                return msg
            return field

        return get_field

    @property
    def context(self):
        """
        If this Message object belongs to a nested field, the context of the field is returned.
        Else, None is returned.
        """
        if self._parent_field is not None:
            return self._parent_field.context
        return None

    @context.setter
    def context(self, context):
        """
        If this Message object belongs to a nested field, set the context of the field.
        Else, raise an exception.

        #TODO: Determine which exception to raise when not a nested field
        #TODO: Determine which exception to raise when context is not derived from the MessageClass.
        """
        assert self._parent_field is not None
        self._parent_field.context = context

    def update_fields(self) -> None:
        """
        Updates all auto-update fields.

        :raises: CircularDependencyException if auto-update fields depend on each other.
        """
        # Update all auto-update fields
        auto_update_fields = [f for f in self._fields.values() if f.is_auto_updated]

        for field in auto_update_fields:
            field._value = None  # erase old values

        for i in range(len(auto_update_fields)):
            try_again = False
            for field in auto_update_fields:
                field.value = field.value_updater(
                    *[self._fields[arg].value for arg in inspect.getfullargspec(field.value_updater)[0]]
                )
                if field._value is None:
                    try_again = True

            if not try_again:
                break

    def render(self) -> str:
        """Renders entire field object as a hexadecimal value."""
        bin_data = f"b{''.join([data.render(fmt=Field.Format.Bin)[1:] for data in self._fields.values()])}"
        return Field.render_value(value=bin_data, fmt=Field.Format.Hex, pad_to_length=len(self) // 4)

    def render_table(self, formats=(Field.Format.Hex, Field.Format.Bin)) -> str:
        """
        Renders the Message object as an ASCII table. The first column specifies the name of each field
        and each subsequent column contains each field rendered in a specific format. The formats that
        fields are rendered as is dictated by the value of the `formats` parameter.
        """
        # Calculate column widths based on max lengths
        max_field_name_length = len(max(self._fields.keys(), key=len))
        max_format_lens = []
        for fmt in formats:
            max_format_lens.append(len(max([f.render(fmt=fmt) for f in self._fields.values()], key=len)))

        # Build header
        name_col_fmt = "| {:^" + str(max_field_name_length) + "s} |"
        hdr = name_col_fmt.format("Field")
        for fmt, l in zip(formats, max_format_lens):
            column_fmt = " {:^" + str(l) + "s} |"
            hdr += column_fmt.format(fmt.name)

        hdr_bars = f"+={'='*max_field_name_length}=+"
        for l in max_format_lens:
            hdr_bars += f"={'='*l}=+"
        row_separator = hdr_bars.replace("=", "-")

        ascii_table = f"{hdr_bars}\n{hdr}\n{hdr_bars}"

        # Build field rows
        for fieldname, field in self._fields.items():

            name_col_fmt = "| {:<" + str(max_field_name_length) + "s} |"
            row = name_col_fmt.format(fieldname)

            for fmt, l in zip(formats, max_format_lens):
                column_fmt = " {:<" + str(l) + "s} |"
                row += column_fmt.format(field.render(fmt=fmt))

            ascii_table += f"\n{row}\n{row_separator}"

        return ascii_table

    def compare_tables(self, other_message):
        """
        Constructs an ASCII representation of the message comparison. The tables for each
        message are displayed side-by-side. Fields that differ are denoted by `!=` between
        the tables in the corresponding row and fields that are equivalent are denoted
        by `==` in the same manner.
        """
        my_table = self.render_table().split("\n")
        other_table = other_message.render_table().split("\n")

        comps = {}
        counter = 3
        for field1, field2 in zip(self._fields.values(), other_message._fields.values()):
            comps[counter] = field1.value == field2.value
            counter += 2

        counter = 0
        for my_line, other_line in zip(my_table, other_table):
            if counter in comps:
                comp = "==" if comps[counter] is True else "!="
            else:
                comp = "  "

            print(f"{my_line}  {comp}  {other_line}")
            counter += 1

        return False in comps

    def __len__(self):
        """Returns the total number of bits in the message."""
        return type(self).bit_length

    @classmethod
    def from_data(cls, data):
        """
        Constructs an object of type cls given an entire hex message.

        #TODO: take a context tree as a parameter to allow construction of nested messages

        :raises: InvalidDataFormatException if the object could not be created due to issues with the format of the data
        """

        # 1. Convert the data to binary
        binary_data = Field.render_value(value=data, fmt=Field.Format.Bin, pad_to_length=cls.bit_length)[1:]

        # 2. chunk into fields
        writable_field_data = {}
        for fieldname, field in cls.format.items():
            if field.is_writable:
                writable_field_data[fieldname] = f"b{binary_data[:len(field)]}"
            binary_data = binary_data[len(field) :]

        # 3. Construct a new message providing data only for writable fields.
        try:
            return cls(**writable_field_data)
        except (MissingFieldDataException, InvalidFieldDataException) as e:
            raise InvalidDataFormatException(f"the data '{data}' doesn't fit the format for '{cls.__name__}'")
